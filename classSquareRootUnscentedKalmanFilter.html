<!-- HTML header for doxygen 1.9.6-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>RIT VEXU Core API: SquareRootUnscentedKalmanFilter&lt; STATES, INPUTS, OUTPUTS &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
        <script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript">
	DoxygenAwesomeDarkModeToggle.init()
</script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">RIT VEXU Core API
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('classSquareRootUnscentedKalmanFilter.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classSquareRootUnscentedKalmanFilter-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">SquareRootUnscentedKalmanFilter&lt; STATES, INPUTS, OUTPUTS &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="srukf_8h_source.html">srukf.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:afd3e14d1509b13ad2cfd30563f16184e" id="r_afd3e14d1509b13ad2cfd30563f16184e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afd3e14d1509b13ad2cfd30563f16184e">SquareRootUnscentedKalmanFilter</a> (const std::function&lt; StateVector(const StateVector &amp;, const InputVector &amp;)&gt; &amp;f, const std::function&lt; OutputVector(const StateVector &amp;, const InputVector &amp;)&gt; &amp;h, const WithInputIntegrator &amp;integrator, const StateVector &amp;state_stddevs, const OutputVector &amp;measurement_stddevs)</td></tr>
<tr class="separator:afd3e14d1509b13ad2cfd30563f16184e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6933a83c834261a3f8e9ce0b47aa492" id="r_ae6933a83c834261a3f8e9ce0b47aa492"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae6933a83c834261a3f8e9ce0b47aa492">SquareRootUnscentedKalmanFilter</a> (const std::function&lt; StateVector(const StateVector &amp;, const InputVector &amp;)&gt; &amp;f, const std::function&lt; OutputVector(const StateVector &amp;, const InputVector &amp;)&gt; &amp;h, const WithInputIntegrator &amp;integrator, const StateVector &amp;state_stddevs, const OutputVector &amp;measurement_stddevs, const std::function&lt; StateVector(const EMat&lt; STATES, NUM_SIGMAS &gt; &amp;, const EVec&lt; NUM_SIGMAS &gt; &amp;)&gt; &amp;mean_func_X, const std::function&lt; OutputVector(const EMat&lt; OUTPUTS, NUM_SIGMAS &gt; &amp;, const EVec&lt; NUM_SIGMAS &gt; &amp;)&gt; &amp;mean_func_Y, const std::function&lt; StateVector(const StateVector &amp;, const StateVector &amp;)&gt; &amp;residual_func_X, const std::function&lt; OutputVector(const OutputVector &amp;, const OutputVector &amp;)&gt; &amp;residual_func_Y, const std::function&lt; StateVector(const StateVector &amp;, const StateVector &amp;)&gt; &amp;add_func_X)</td></tr>
<tr class="separator:ae6933a83c834261a3f8e9ce0b47aa492"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96816ae886b6bffc4e980b6714a6ee9c" id="r_a96816ae886b6bffc4e980b6714a6ee9c"><td class="memItemLeft" align="right" valign="top">StateMatrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a96816ae886b6bffc4e980b6714a6ee9c">S</a> () const</td></tr>
<tr class="separator:a96816ae886b6bffc4e980b6714a6ee9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f57cca25fa4c557060191f0f0e9876d" id="r_a7f57cca25fa4c557060191f0f0e9876d"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7f57cca25fa4c557060191f0f0e9876d">S</a> (int i, int j) const</td></tr>
<tr class="separator:a7f57cca25fa4c557060191f0f0e9876d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cf88e34b8952417af9fb9cfaef5af7d" id="r_a8cf88e34b8952417af9fb9cfaef5af7d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8cf88e34b8952417af9fb9cfaef5af7d">set_S</a> (const StateMatrix &amp;<a class="el" href="#a96816ae886b6bffc4e980b6714a6ee9c">S</a>)</td></tr>
<tr class="separator:a8cf88e34b8952417af9fb9cfaef5af7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0af67c0ae39459fce88f82b9fc22dc27" id="r_a0af67c0ae39459fce88f82b9fc22dc27"><td class="memItemLeft" align="right" valign="top">StateMatrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0af67c0ae39459fce88f82b9fc22dc27">P</a> () const</td></tr>
<tr class="separator:a0af67c0ae39459fce88f82b9fc22dc27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a827dab2db283d809d6f04b0275823c84" id="r_a827dab2db283d809d6f04b0275823c84"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a827dab2db283d809d6f04b0275823c84">set_P</a> (const StateMatrix &amp;<a class="el" href="#a0af67c0ae39459fce88f82b9fc22dc27">P</a>)</td></tr>
<tr class="separator:a827dab2db283d809d6f04b0275823c84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a492a3439f577ae81ca698bded59d7a20" id="r_a492a3439f577ae81ca698bded59d7a20"><td class="memItemLeft" align="right" valign="top">StateVector&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a492a3439f577ae81ca698bded59d7a20">xhat</a> () const</td></tr>
<tr class="separator:a492a3439f577ae81ca698bded59d7a20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88c50fdf0b5a9df98262031f9ccaccf3" id="r_a88c50fdf0b5a9df98262031f9ccaccf3"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a88c50fdf0b5a9df98262031f9ccaccf3">xhat</a> (int i) const</td></tr>
<tr class="separator:a88c50fdf0b5a9df98262031f9ccaccf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad847789908004444b3981dc7dfa03df6" id="r_ad847789908004444b3981dc7dfa03df6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad847789908004444b3981dc7dfa03df6">set_xhat</a> (const StateVector &amp;<a class="el" href="#a492a3439f577ae81ca698bded59d7a20">xhat</a>)</td></tr>
<tr class="separator:ad847789908004444b3981dc7dfa03df6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada4c26437626896b05e61a32a81e1970" id="r_ada4c26437626896b05e61a32a81e1970"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ada4c26437626896b05e61a32a81e1970">set_xhat</a> (int i, double value)</td></tr>
<tr class="separator:ada4c26437626896b05e61a32a81e1970"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b571053ad7a8ab83df6e89de5a8ac44" id="r_a2b571053ad7a8ab83df6e89de5a8ac44"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2b571053ad7a8ab83df6e89de5a8ac44">reset</a> ()</td></tr>
<tr class="separator:a2b571053ad7a8ab83df6e89de5a8ac44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85e48f109dd420b53d33340b07c0b668" id="r_a85e48f109dd420b53d33340b07c0b668"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a85e48f109dd420b53d33340b07c0b668">predict</a> (const InputVector &amp;u, double dt)</td></tr>
<tr class="separator:a85e48f109dd420b53d33340b07c0b668"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07b10dbd2972135db30a0829674f8808" id="r_a07b10dbd2972135db30a0829674f8808"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a07b10dbd2972135db30a0829674f8808">correct</a> (const InputVector &amp;u, const OutputVector &amp;y)</td></tr>
<tr class="separator:a07b10dbd2972135db30a0829674f8808"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad83a3be12421f5b1f8b5570a74d1aa34" id="r_ad83a3be12421f5b1f8b5570a74d1aa34"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad83a3be12421f5b1f8b5570a74d1aa34">correct</a> (const InputVector &amp;u, const OutputVector &amp;y, const EVec&lt; OUTPUTS &gt; &amp;measurement_stddevs)</td></tr>
<tr class="separator:ad83a3be12421f5b1f8b5570a74d1aa34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a084621a6545f23a9b8e535d448a4c21e" id="r_a084621a6545f23a9b8e535d448a4c21e"><td class="memTemplParams" colspan="2">template&lt;int ROWS&gt; </td></tr>
<tr class="memitem:a084621a6545f23a9b8e535d448a4c21e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a084621a6545f23a9b8e535d448a4c21e">correct</a> (const InputVector &amp;u, const EVec&lt; ROWS &gt; &amp;y, const std::function&lt; EVec&lt; ROWS &gt;(const StateVector &amp;, const InputVector &amp;)&gt; &amp;h, const EVec&lt; ROWS &gt; &amp;measurement_stddevs)</td></tr>
<tr class="separator:a084621a6545f23a9b8e535d448a4c21e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc74a78d8bac27d353063855272cb374" id="r_abc74a78d8bac27d353063855272cb374"><td class="memTemplParams" colspan="2">template&lt;int ROWS&gt; </td></tr>
<tr class="memitem:abc74a78d8bac27d353063855272cb374"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#abc74a78d8bac27d353063855272cb374">correct</a> (const InputVector &amp;u, const EVec&lt; ROWS &gt; &amp;y, const std::function&lt; EVec&lt; ROWS &gt;(const StateVector &amp;, const InputVector &amp;)&gt; &amp;h, const EVec&lt; ROWS &gt; measurement_stddevs, const std::function&lt; EVec&lt; ROWS &gt;(const EMat&lt; ROWS, NUM_SIGMAS &gt; &amp;, const EVec&lt; NUM_SIGMAS &gt; &amp;)&gt; &amp;mean_func_Y, const std::function&lt; EVec&lt; ROWS &gt;(const EVec&lt; ROWS &gt; &amp;, const EVec&lt; ROWS &gt; &amp;)&gt; &amp;residual_func_Y, const std::function&lt; StateVector(const StateVector &amp;, const StateVector &amp;)&gt; &amp;residual_func_X, const std::function&lt; StateVector(const StateVector &amp;, const StateVector &amp;)&gt; &amp;add_func_X)</td></tr>
<tr class="separator:abc74a78d8bac27d353063855272cb374"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;int STATES, int INPUTS, int OUTPUTS&gt;<br />
class SquareRootUnscentedKalmanFilter&lt; STATES, INPUTS, OUTPUTS &gt;</div><p>Kalman filters combine predictions from a model and measurements to estimate a system's true state.</p>
<p>The Unscented Kalman <a class="el" href="classFilter.html">Filter</a> is a nonlinear estimator, meaning that the model used to predict how the state changes over time can be nonlinear. The model that determines the expected measurement given the current state can also be nonlinear.</p>
<p>At each timestep, sigma points are generated close to the mean, they are all propagated forward in time according to the nonlinear model. The Unscented Transform uses the propagated sigma points to compute the prior state and covariance.</p>
<p>When correcting the state and covariance with a measurement, sigma points are again generated, but are transformed into the measurement space using the measurement function. A Kalman gain matrix K is then computed, and used to update the state and covariance.</p>
<p>To read more about Kalman filters and the standard UKF read: <a href="https://github.com/rlabbe/Kalman-and-Bayesian-Filters-in-Python">https://github.com/rlabbe/Kalman-and-Bayesian-Filters-in-Python</a></p>
<p>This implementation is somewhat non-standard. The square-root form of the UKF (SR-UKF) is used, and the way the sigma points are generated is different than most implementations. The square-root form is used to ensure that the covariance matrix remains positive definite.</p>
<p>To learn more about the SR-UKF, and see the exact formulation that most of this implementation follows, read: <a href="https://www.researchgate.net/publication/3908304">https://www.researchgate.net/publication/3908304</a></p>
<p>The sigma points are not generated symmetrically around the mean, instead they are generated as vertices of a simplex. Using N = # of states, this method uses N + 2 sigma points instead of the standard 2N + 1 sigma points. This reduces computation up to 50%. To learn more about this method, read: <a href="https://www.sciencedirect.com/science/article/pii/S0888327020308190">https://www.sciencedirect.com/science/article/pii/S0888327020308190</a></p>
<p>This filter uses a method of "recalibrating" by essentially applying a measurement twice instead of once, and only using it if it is more accurate than before the measurement was applied. To learn more about this framework for nonlinear filters, read: <a href="https://arxiv.org/pdf/2407.05717">https://arxiv.org/pdf/2407.05717</a></p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">STATES</td><td>Dimension of the state vector. </td></tr>
    <tr><td class="paramname">INPUTS</td><td>Dimension of the control input vector. </td></tr>
    <tr><td class="paramname">OUTPUTS</td><td>Dimension of the measurement vector. </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="afd3e14d1509b13ad2cfd30563f16184e" name="afd3e14d1509b13ad2cfd30563f16184e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd3e14d1509b13ad2cfd30563f16184e">&#9670;&#160;</a></span>SquareRootUnscentedKalmanFilter() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int STATES, int INPUTS, int OUTPUTS&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSquareRootUnscentedKalmanFilter.html">SquareRootUnscentedKalmanFilter</a>&lt; STATES, INPUTS, OUTPUTS &gt;<a class="el" href="classSquareRootUnscentedKalmanFilter.html">::SquareRootUnscentedKalmanFilter</a> </td>
          <td>(</td>
          <td class="paramtype">const std::function&lt; StateVector(const StateVector &amp;, const InputVector &amp;)&gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; OutputVector(const StateVector &amp;, const InputVector &amp;)&gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>h</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const WithInputIntegrator &amp;</td>          <td class="paramname"><span class="paramname"><em>integrator</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const StateVector &amp;</td>          <td class="paramname"><span class="paramname"><em>state_stddevs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const OutputVector &amp;</td>          <td class="paramname"><span class="paramname"><em>measurement_stddevs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Constructs an Unscented Kalman <a class="el" href="classFilter.html">Filter</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>A vector valued function of x and u that returns the derivative of the state vector with respect to time. </td></tr>
    <tr><td class="paramname">h</td><td>A vector valued function of x and u that returns the expected measurement at the given state. </td></tr>
    <tr><td class="paramname">integrator</td><td>A function from "numerical_integration.h" that integrates a differential equation of the form f(x, u). </td></tr>
    <tr><td class="paramname">state_stddevs</td><td>Standard deviations of the states in the model. </td></tr>
    <tr><td class="paramname">measurement_stddevs</td><td>Standard deviations of the measurements. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae6933a83c834261a3f8e9ce0b47aa492" name="ae6933a83c834261a3f8e9ce0b47aa492"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6933a83c834261a3f8e9ce0b47aa492">&#9670;&#160;</a></span>SquareRootUnscentedKalmanFilter() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int STATES, int INPUTS, int OUTPUTS&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSquareRootUnscentedKalmanFilter.html">SquareRootUnscentedKalmanFilter</a>&lt; STATES, INPUTS, OUTPUTS &gt;<a class="el" href="classSquareRootUnscentedKalmanFilter.html">::SquareRootUnscentedKalmanFilter</a> </td>
          <td>(</td>
          <td class="paramtype">const std::function&lt; StateVector(const StateVector &amp;, const InputVector &amp;)&gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; OutputVector(const StateVector &amp;, const InputVector &amp;)&gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>h</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const WithInputIntegrator &amp;</td>          <td class="paramname"><span class="paramname"><em>integrator</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const StateVector &amp;</td>          <td class="paramname"><span class="paramname"><em>state_stddevs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const OutputVector &amp;</td>          <td class="paramname"><span class="paramname"><em>measurement_stddevs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; StateVector(const EMat&lt; STATES, NUM_SIGMAS &gt; &amp;, const EVec&lt; NUM_SIGMAS &gt; &amp;)&gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>mean_func_X</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; OutputVector(const EMat&lt; OUTPUTS, NUM_SIGMAS &gt; &amp;, const EVec&lt; NUM_SIGMAS &gt; &amp;)&gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>mean_func_Y</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; StateVector(const StateVector &amp;, const StateVector &amp;)&gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>residual_func_X</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; OutputVector(const OutputVector &amp;, const OutputVector &amp;)&gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>residual_func_Y</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; StateVector(const StateVector &amp;, const StateVector &amp;)&gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>add_func_X</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Constructs an Unscented Kalman <a class="el" href="classFilter.html">Filter</a> with custom mean, residual, and addition functions. The most common use for these functions is when you are estimating angles whose arithmetic operations need to be wrapped.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>A vector valued function of x and u that returns the derivative of the state vector with respect to time. </td></tr>
    <tr><td class="paramname">h</td><td>A vector valued function of x and u that returns the expected measurement at the given state. </td></tr>
    <tr><td class="paramname">integrator</td><td>A function from "numerical_integration.h" that integrates a differential equation of the form f(x, u). </td></tr>
    <tr><td class="paramname">state_stddevs</td><td>Standard deviations of the states in the model. </td></tr>
    <tr><td class="paramname">measurement_stddevs</td><td>Standard deviations of the measurements. </td></tr>
    <tr><td class="paramname">mean_func_X</td><td>A function that computes the mean of a matrix containing NUM_SIGMAS state sigma points with a set of weights for each. </td></tr>
    <tr><td class="paramname">mean_func_Y</td><td>A function that computes the mean of a matrix containing NUM_SIGMAS measurement sigma points with a set of weights for each. </td></tr>
    <tr><td class="paramname">residual_func_X</td><td>A function that computes the residual of two state vectors, usually by simple subtraction. </td></tr>
    <tr><td class="paramname">residual_func_Y</td><td>A function that computes the residual of two measurement vectors, usually by simple subtraction. </td></tr>
    <tr><td class="paramname">add_funx_X</td><td>A function that adds two state vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a084621a6545f23a9b8e535d448a4c21e" name="a084621a6545f23a9b8e535d448a4c21e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a084621a6545f23a9b8e535d448a4c21e">&#9670;&#160;</a></span>correct() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int STATES, int INPUTS, int OUTPUTS&gt; </div>
<div class="memtemplate">
template&lt;int ROWS&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSquareRootUnscentedKalmanFilter.html">SquareRootUnscentedKalmanFilter</a>&lt; STATES, INPUTS, OUTPUTS &gt;::correct </td>
          <td>(</td>
          <td class="paramtype">const InputVector &amp;</td>          <td class="paramname"><span class="paramname"><em>u</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const EVec&lt; ROWS &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>y</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; EVec&lt; ROWS &gt;(const StateVector &amp;, const InputVector &amp;)&gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>h</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const EVec&lt; ROWS &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>measurement_stddevs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Correct the state estimate using the measurements in y, a custom measurement function, and custom standard deviations. This is useful for when a different set of measurements are being applied.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">u</td><td>The control input used in the last predict step. </td></tr>
    <tr><td class="paramname">y</td><td>The vector of measurements. </td></tr>
    <tr><td class="paramname">h</td><td>A vector valued function of x and u that returns the expected measurement at the given state. </td></tr>
    <tr><td class="paramname">measurement_stddevs</td><td>The vector of standard deviations for each measurement to be used for this correct step. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abc74a78d8bac27d353063855272cb374" name="abc74a78d8bac27d353063855272cb374"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc74a78d8bac27d353063855272cb374">&#9670;&#160;</a></span>correct() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int STATES, int INPUTS, int OUTPUTS&gt; </div>
<div class="memtemplate">
template&lt;int ROWS&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSquareRootUnscentedKalmanFilter.html">SquareRootUnscentedKalmanFilter</a>&lt; STATES, INPUTS, OUTPUTS &gt;::correct </td>
          <td>(</td>
          <td class="paramtype">const InputVector &amp;</td>          <td class="paramname"><span class="paramname"><em>u</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const EVec&lt; ROWS &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>y</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; EVec&lt; ROWS &gt;(const StateVector &amp;, const InputVector &amp;)&gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>h</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const EVec&lt; ROWS &gt;</td>          <td class="paramname"><span class="paramname"><em>measurement_stddevs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; EVec&lt; ROWS &gt;(const EMat&lt; ROWS, NUM_SIGMAS &gt; &amp;, const EVec&lt; NUM_SIGMAS &gt; &amp;)&gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>mean_func_Y</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; EVec&lt; ROWS &gt;(const EVec&lt; ROWS &gt; &amp;, const EVec&lt; ROWS &gt; &amp;)&gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>residual_func_Y</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; StateVector(const StateVector &amp;, const StateVector &amp;)&gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>residual_func_X</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; StateVector(const StateVector &amp;, const StateVector &amp;)&gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>add_func_X</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Correct the state estimate using the measurements in y, a custom measurement function, custom standard deviations, and custom mean, residual, and addition functions. This is useful for when a different set of measurements are being applied, and they require custom arithmetic functions.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">u</td><td>The control input used in the last predict step. </td></tr>
    <tr><td class="paramname">y</td><td>The vector of measurements. </td></tr>
    <tr><td class="paramname">h</td><td>A vector valued function of x and u that returns the expected measurement at the given state. </td></tr>
    <tr><td class="paramname">measurement_stddevs</td><td>The vector of standard deviations for each measurement to be used for this correct step. </td></tr>
    <tr><td class="paramname">mean_func_Y</td><td>A function that computes the mean of a matrix containing NUM_SIGMAS measurement sigma points with a set of weights for each. </td></tr>
    <tr><td class="paramname">residual_func_X</td><td>A function that computes the residual of two state vectors, usually by simple subtraction. </td></tr>
    <tr><td class="paramname">residual_func_Y</td><td>A function that computes the residual of two measurement vectors, usually by simple subtraction. </td></tr>
    <tr><td class="paramname">add_funx_X</td><td>A function that adds two state vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a07b10dbd2972135db30a0829674f8808" name="a07b10dbd2972135db30a0829674f8808"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07b10dbd2972135db30a0829674f8808">&#9670;&#160;</a></span>correct() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int STATES, int INPUTS, int OUTPUTS&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSquareRootUnscentedKalmanFilter.html">SquareRootUnscentedKalmanFilter</a>&lt; STATES, INPUTS, OUTPUTS &gt;::correct </td>
          <td>(</td>
          <td class="paramtype">const InputVector &amp;</td>          <td class="paramname"><span class="paramname"><em>u</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const OutputVector &amp;</td>          <td class="paramname"><span class="paramname"><em>y</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Correct the state estimate using the measurements in y.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">u</td><td>The control input used in the last predict step. </td></tr>
    <tr><td class="paramname">y</td><td>The vector of measurements. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad83a3be12421f5b1f8b5570a74d1aa34" name="ad83a3be12421f5b1f8b5570a74d1aa34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad83a3be12421f5b1f8b5570a74d1aa34">&#9670;&#160;</a></span>correct() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int STATES, int INPUTS, int OUTPUTS&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSquareRootUnscentedKalmanFilter.html">SquareRootUnscentedKalmanFilter</a>&lt; STATES, INPUTS, OUTPUTS &gt;::correct </td>
          <td>(</td>
          <td class="paramtype">const InputVector &amp;</td>          <td class="paramname"><span class="paramname"><em>u</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const OutputVector &amp;</td>          <td class="paramname"><span class="paramname"><em>y</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const EVec&lt; OUTPUTS &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>measurement_stddevs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Correct the state estimate using the measurements in y, and custom standard deviations. This is useful for when the noise in the measurements vary.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">u</td><td>The control input used in the last predict step. </td></tr>
    <tr><td class="paramname">y</td><td>The vector of measurements. </td></tr>
    <tr><td class="paramname">measurement_stddevs</td><td>The vector of standard deviations for each measurement to be used for this correct step. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0af67c0ae39459fce88f82b9fc22dc27" name="a0af67c0ae39459fce88f82b9fc22dc27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0af67c0ae39459fce88f82b9fc22dc27">&#9670;&#160;</a></span>P()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int STATES, int INPUTS, int OUTPUTS&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">StateMatrix <a class="el" href="classSquareRootUnscentedKalmanFilter.html">SquareRootUnscentedKalmanFilter</a>&lt; STATES, INPUTS, OUTPUTS &gt;::P </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the reconstructed covariance matrix P. </p>

</div>
</div>
<a id="a85e48f109dd420b53d33340b07c0b668" name="a85e48f109dd420b53d33340b07c0b668"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85e48f109dd420b53d33340b07c0b668">&#9670;&#160;</a></span>predict()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int STATES, int INPUTS, int OUTPUTS&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSquareRootUnscentedKalmanFilter.html">SquareRootUnscentedKalmanFilter</a>&lt; STATES, INPUTS, OUTPUTS &gt;::predict </td>
          <td>(</td>
          <td class="paramtype">const InputVector &amp;</td>          <td class="paramname"><span class="paramname"><em>u</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>dt</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Projects the state into the future by dt seconds with control input u.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">u</td><td>The control input. </td></tr>
    <tr><td class="paramname">dt</td><td>The timestep in seconds. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2b571053ad7a8ab83df6e89de5a8ac44" name="a2b571053ad7a8ab83df6e89de5a8ac44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b571053ad7a8ab83df6e89de5a8ac44">&#9670;&#160;</a></span>reset()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int STATES, int INPUTS, int OUTPUTS&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSquareRootUnscentedKalmanFilter.html">SquareRootUnscentedKalmanFilter</a>&lt; STATES, INPUTS, OUTPUTS &gt;::reset </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Resets the filter. Make sure to explicitly set S after calling this. </p>

</div>
</div>
<a id="a96816ae886b6bffc4e980b6714a6ee9c" name="a96816ae886b6bffc4e980b6714a6ee9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96816ae886b6bffc4e980b6714a6ee9c">&#9670;&#160;</a></span>S() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int STATES, int INPUTS, int OUTPUTS&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">StateMatrix <a class="el" href="classSquareRootUnscentedKalmanFilter.html">SquareRootUnscentedKalmanFilter</a>&lt; STATES, INPUTS, OUTPUTS &gt;::S </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the square-root covariance matrix S. </p>

</div>
</div>
<a id="a7f57cca25fa4c557060191f0f0e9876d" name="a7f57cca25fa4c557060191f0f0e9876d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f57cca25fa4c557060191f0f0e9876d">&#9670;&#160;</a></span>S() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int STATES, int INPUTS, int OUTPUTS&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classSquareRootUnscentedKalmanFilter.html">SquareRootUnscentedKalmanFilter</a>&lt; STATES, INPUTS, OUTPUTS &gt;::S </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>i</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>j</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns one element of the square-root covariance matrix S.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>Row of S. </td></tr>
    <tr><td class="paramname">j</td><td>Column of S. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a827dab2db283d809d6f04b0275823c84" name="a827dab2db283d809d6f04b0275823c84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a827dab2db283d809d6f04b0275823c84">&#9670;&#160;</a></span>set_P()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int STATES, int INPUTS, int OUTPUTS&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSquareRootUnscentedKalmanFilter.html">SquareRootUnscentedKalmanFilter</a>&lt; STATES, INPUTS, OUTPUTS &gt;::set_P </td>
          <td>(</td>
          <td class="paramtype">const StateMatrix &amp;</td>          <td class="paramname"><span class="paramname"><em>P</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the current square-root covariance matrix S to the square-root of P.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">P</td><td>The covariance matrix P. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8cf88e34b8952417af9fb9cfaef5af7d" name="a8cf88e34b8952417af9fb9cfaef5af7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8cf88e34b8952417af9fb9cfaef5af7d">&#9670;&#160;</a></span>set_S()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int STATES, int INPUTS, int OUTPUTS&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSquareRootUnscentedKalmanFilter.html">SquareRootUnscentedKalmanFilter</a>&lt; STATES, INPUTS, OUTPUTS &gt;::set_S </td>
          <td>(</td>
          <td class="paramtype">const StateMatrix &amp;</td>          <td class="paramname"><span class="paramname"><em>S</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the current square-root covariance matrix S.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">S</td><td>The new square-root covariance matrix S. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad847789908004444b3981dc7dfa03df6" name="ad847789908004444b3981dc7dfa03df6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad847789908004444b3981dc7dfa03df6">&#9670;&#160;</a></span>set_xhat() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int STATES, int INPUTS, int OUTPUTS&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSquareRootUnscentedKalmanFilter.html">SquareRootUnscentedKalmanFilter</a>&lt; STATES, INPUTS, OUTPUTS &gt;::set_xhat </td>
          <td>(</td>
          <td class="paramtype">const StateVector &amp;</td>          <td class="paramname"><span class="paramname"><em>xhat</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the current state estimate x-hat. </p>

</div>
</div>
<a id="ada4c26437626896b05e61a32a81e1970" name="ada4c26437626896b05e61a32a81e1970"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada4c26437626896b05e61a32a81e1970">&#9670;&#160;</a></span>set_xhat() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int STATES, int INPUTS, int OUTPUTS&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSquareRootUnscentedKalmanFilter.html">SquareRootUnscentedKalmanFilter</a>&lt; STATES, INPUTS, OUTPUTS &gt;::set_xhat </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>i</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set one element of the current state estimate x-hat.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>Row of x-hat. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a492a3439f577ae81ca698bded59d7a20" name="a492a3439f577ae81ca698bded59d7a20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a492a3439f577ae81ca698bded59d7a20">&#9670;&#160;</a></span>xhat() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int STATES, int INPUTS, int OUTPUTS&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">StateVector <a class="el" href="classSquareRootUnscentedKalmanFilter.html">SquareRootUnscentedKalmanFilter</a>&lt; STATES, INPUTS, OUTPUTS &gt;::xhat </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the current state estimate x-hat. </p>

</div>
</div>
<a id="a88c50fdf0b5a9df98262031f9ccaccf3" name="a88c50fdf0b5a9df98262031f9ccaccf3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88c50fdf0b5a9df98262031f9ccaccf3">&#9670;&#160;</a></span>xhat() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int STATES, int INPUTS, int OUTPUTS&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classSquareRootUnscentedKalmanFilter.html">SquareRootUnscentedKalmanFilter</a>&lt; STATES, INPUTS, OUTPUTS &gt;::xhat </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>i</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns one element of the current state estimate x-hat.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>Row of x-hat. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="srukf_8h_source.html">srukf.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="classSquareRootUnscentedKalmanFilter.html">SquareRootUnscentedKalmanFilter</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
